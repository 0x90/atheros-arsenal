--- a/drivers/net/wireless/ath/ath9k/debug.c	2013-03-07 21:37:03.000000000 +0800
+++ b/drivers/net/wireless/ath/ath9k/debug.c	2013-03-07 15:26:43.000000000 +0800
@@ -1915,13 +1915,13 @@
 		return -ENOMEM;
 	}
 
-	/*len += snprintf(buf + len, size - len,
+	len += snprintf(buf + len, size - len,
 			"%4s%4s%4s%10s%10s%10s%10s%8s%10s%8s%12s%8s\n", "sec", "mcs", "nf",
-			"rx-bytes", "noretry", "rssi_all", "noise_all", "nrssi", "lost", "total", "throughput", "rssi");*/
+			"rx-bytes", "noretry", "rssi_all", "noise_all", "nrssi", "lost", "total", "throughput", "rssi");
 
 	list_for_each_entry(cursor, tp_list, list){
-		/*if (cursor->sec == 0)
-			len += snprintf(buf + len, size - len, "\n");*/
+		if (cursor->sec == 0)
+			len += snprintf(buf + len, size - len, "\n");
 		u16 tp = cursor->tp * 8 / 1024 / 1024;
 		u8 rssi = cursor->rssi / cursor->rssi_counter;
 		len += snprintf(buf + len, size - len,
@@ -2014,13 +2014,13 @@
 		return -ENOMEM;
 	}
 
-	/*len += snprintf(buf + len, size - len,
+	len += snprintf(buf + len, size - len,
 			"%4s%4s%4s%10s%10s%10s%10s%12s\n", "sec", "mcs", "nf",
-			"tx_bytes", "aggr_num", "faggr_num", "naggr_num", "bandwidth");*/
+			"tx_bytes", "aggr_num", "faggr_num", "naggr_num", "bandwidth");
 
 	list_for_each_entry(cursor, bw_list, list){
-		/*if (cursor->sec == 0)
-			len += snprintf(buf + len, size - len, "\n");*/
+		if (cursor->sec == 0)
+			len += snprintf(buf + len, size - len, "\n");
 		u16 bw = cursor->tx_bytes * 8 / 1024 / 1024;
 		len += snprintf(buf + len, size - len,
 			"%4u%4u%4u%10u%10u%10u%10u%8uMbps\n", cursor->sec, cursor->mcs, cursor->nframe,
@@ -2088,13 +2088,13 @@
 		return -ENOMEM;
 	}
 
-	/*len += snprintf(buf + len, size - len,
+	len += snprintf(buf + len, size - len,
 			"%4s%10s%10s%10s%10s%12s\n", "sec", "tp_all", "pkts_all",
-			"crcerr", "phyerr", "rate");*/
+			"crcerr", "phyerr", "rate");
 
 	list_for_each_entry(cursor, ri_list, list){
-		/*if (cursor->sec == 0)
-			len += snprintf(buf + len, size - len, "\n");*/
+		if (cursor->sec == 0)
+			len += snprintf(buf + len, size - len, "\n");
 		u16 rate = cursor->rx_all_bytes * 8 / 1024 / 1024;
 		len += snprintf(buf + len, size - len,
 				"%4u%10u%10u%10u%10u%8uMbps\n", cursor->sec, cursor->rx_all_bytes,
--- a/drivers/net/wireless/ath/ath9k/rc.c	2013-03-07 21:37:03.000000000 +0800
+++ b/drivers/net/wireless/ath/ath9k/rc.c	2013-03-07 21:11:14.000000000 +0800
@@ -1,3 +1,4 @@
+/* !!!file to change!!! */
 /*
  * Copyright (c) 2004 Video54 Technologies, Inc.
  * Copyright (c) 2004-2011 Atheros Communications, Inc.
@@ -20,149 +21,92 @@
 
 #include "ath9k.h"
 
+/* the rate table just for reference, we don't use it any more */
 static const struct ath_rate_table ar5416_11na_ratetable = {
-	68,
+	32,
 	8, /* MCS start */
 	{
-		[0] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 6000,
-			5400, 0, 12, 0, 0, 0, 0 }, /* 6 Mb */
-		[1] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 9000,
-			7800,  1, 18, 0, 1, 1, 1 }, /* 9 Mb */
-		[2] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 12000,
-			10000, 2, 24, 2, 2, 2, 2 }, /* 12 Mb */
-		[3] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 18000,
-			13900, 3, 36, 2, 3, 3, 3 }, /* 18 Mb */
-		[4] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 24000,
-			17300, 4, 48, 4, 4, 4, 4 }, /* 24 Mb */
-		[5] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 36000,
-			23000, 5, 72, 4, 5, 5, 5 }, /* 36 Mb */
-		[6] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 48000,
-			27400, 6, 96, 4, 6, 6, 6 }, /* 48 Mb */
-		[7] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 54000,
-			29300, 7, 108, 4, 7, 7, 7 }, /* 54 Mb */
-		[8] = { RC_HT_SDT_2040, WLAN_RC_PHY_HT_20_SS, 6500,
-			6400, 0, 0, 0, 38, 8, 38 }, /* 6.5 Mb */
-		[9] = { RC_HT_SDT_20, WLAN_RC_PHY_HT_20_SS, 13000,
-			12700, 1, 1, 2, 39, 9, 39 }, /* 13 Mb */
-		[10] = { RC_HT_SDT_20, WLAN_RC_PHY_HT_20_SS, 19500,
-			18800, 2, 2, 2, 40, 10, 40 }, /* 19.5 Mb */
-		[11] = { RC_HT_SD_20, WLAN_RC_PHY_HT_20_SS, 26000,
-			25000, 3, 3, 4, 41, 11, 41 }, /* 26 Mb */
-		[12] = { RC_HT_SD_20, WLAN_RC_PHY_HT_20_SS, 39000,
-			36700, 4, 4, 4, 42, 12, 42 }, /* 39 Mb */
-		[13] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 52000,
-			48100, 5, 5, 4, 43, 13, 43 }, /* 52 Mb */
-		[14] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 58500,
-			53500, 6, 6, 4, 44, 14, 44 }, /* 58.5 Mb */
-		[15] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 65000,
-			59000, 7, 7, 4, 45, 16, 46 }, /* 65 Mb */
-		[16] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS_HGI, 72200,
-			65400, 7, 7, 4, 45, 16, 46 }, /* 75 Mb */
-		[17] = { RC_INVALID, WLAN_RC_PHY_HT_20_DS, 13000,
-			12700, 8, 8, 0, 47, 17, 47 }, /* 13 Mb */
-		[18] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 26000,
-			24800, 9, 9, 2, 48, 18, 48 }, /* 26 Mb */
-		[19] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 39000,
-			36600, 10, 10, 2, 49, 19, 49 }, /* 39 Mb */
-		[20] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 52000,
-			48100, 11, 11, 4, 50, 20, 50 }, /* 52 Mb */
-		[21] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 78000,
-			69500, 12, 12, 4, 51, 21, 51 }, /* 78 Mb */
-		[22] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 104000,
-			89500, 13, 13, 4, 52, 22, 52 }, /* 104 Mb */
-		[23] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 117000,
-			98900, 14, 14, 4, 53, 23, 53 }, /* 117 Mb */
-		[24] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 130000,
-			108300, 15, 15, 4, 54, 25, 55 }, /* 130 Mb */
-		[25] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS_HGI, 144400,
-			120000, 15, 15, 4, 54, 25, 55 }, /* 144.4 Mb */
-		[26] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 19500,
-			17400, 16, 16, 0, 56, 26, 56 }, /* 19.5 Mb */
-		[27] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 39000,
-			35100, 17, 17, 2, 57, 27, 57 }, /* 39 Mb */
-		[28] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 58500,
-			52600, 18, 18, 2, 58, 28, 58 }, /* 58.5 Mb */
-		[29] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 78000,
-			70400, 19, 19, 4, 59, 29, 59 }, /* 78 Mb */
-		[30] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 117000,
-			104900, 20, 20, 4, 60, 31, 61 }, /* 117 Mb */
-		[31] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS_HGI, 130000,
-			115800, 20, 20, 4, 60, 31, 61 }, /* 130 Mb*/
-		[32] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS, 156000,
-			137200, 21, 21, 4, 62, 33, 63 }, /* 156 Mb */
-		[33] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS_HGI, 173300,
-			151100, 21, 21, 4, 62, 33, 63 }, /* 173.3 Mb */
-		[34] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS, 175500,
-			152800, 22, 22, 4, 64, 35, 65 }, /* 175.5 Mb */
-		[35] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS_HGI, 195000,
-			168400, 22, 22, 4, 64, 35, 65 }, /* 195 Mb*/
-		[36] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS, 195000,
-			168400, 23, 23, 4, 66, 37, 67 }, /* 195 Mb */
-		[37] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS_HGI, 216700,
-			185000, 23, 23, 4, 66, 37, 67 }, /* 216.7 Mb */
-		[38] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 13500,
-			13200, 0, 0, 0, 38, 38, 38 }, /* 13.5 Mb*/
-		[39] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 27500,
-			25900, 1, 1, 2, 39, 39, 39 }, /* 27.0 Mb*/
-		[40] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 40500,
-			38600, 2, 2, 2, 40, 40, 40 }, /* 40.5 Mb*/
-		[41] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 54000,
-			49800, 3, 3, 4, 41, 41, 41 }, /* 54 Mb */
-		[42] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 81500,
-			72200, 4, 4, 4, 42, 42, 42 }, /* 81 Mb */
-		[43] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 108000,
-			92900, 5, 5, 4, 43, 43, 43 }, /* 108 Mb */
-		[44] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 121500,
-			102700, 6, 6, 4, 44, 44, 44 }, /* 121.5 Mb*/
-		[45] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 135000,
-			112000, 7, 7, 4, 45, 46, 46 }, /* 135 Mb */
-		[46] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS_HGI, 150000,
-			122000, 7, 7, 4, 45, 46, 46 }, /* 150 Mb */
-		[47] = { RC_INVALID, WLAN_RC_PHY_HT_40_DS, 27000,
-			25800, 8, 8, 0, 47, 47, 47 }, /* 27 Mb */
-		[48] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 54000,
-			49800, 9, 9, 2, 48, 48, 48 }, /* 54 Mb */
-		[49] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 81000,
-			71900, 10, 10, 2, 49, 49, 49 }, /* 81 Mb */
-		[50] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 108000,
-			92500, 11, 11, 4, 50, 50, 50 }, /* 108 Mb */
-		[51] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 162000,
-			130300, 12, 12, 4, 51, 51, 51 }, /* 162 Mb */
-		[52] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 216000,
-			162800, 13, 13, 4, 52, 52, 52 }, /* 216 Mb */
-		[53] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 243000,
-			178200, 14, 14, 4, 53, 53, 53 }, /* 243 Mb */
-		[54] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 270000,
-			192100, 15, 15, 4, 54, 55, 55 }, /* 270 Mb */
-		[55] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS_HGI, 300000,
-			207000, 15, 15, 4, 54, 55, 55 }, /* 300 Mb */
-		[56] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 40500,
-			36100, 16, 16, 0, 56, 56, 56 }, /* 40.5 Mb */
-		[57] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 81000,
-			72900, 17, 17, 2, 57, 57, 57 }, /* 81 Mb */
-		[58] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 121500,
-			108300, 18, 18, 2, 58, 58, 58 }, /* 121.5 Mb */
-		[59] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 162000,
-			142000, 19, 19, 4, 59, 59, 59 }, /*  162 Mb */
-		[60] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 243000,
-			205100, 20, 20, 4, 60, 61, 61 }, /*  243 Mb */
-		[61] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS_HGI, 270000,
-			224700, 20, 20, 4, 60, 61, 61 }, /*  270 Mb */
-		[62] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS, 324000,
-			263100, 21, 21, 4, 62, 63, 63 }, /*  324 Mb */
-		[63] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS_HGI, 360000,
-			288000, 21, 21, 4, 62, 63, 63 }, /*  360 Mb */
-		[64] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS, 364500,
-			290700, 22, 22, 4, 64, 65, 65 }, /* 364.5 Mb */
-		[65] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS_HGI, 405000,
-			317200, 22, 22, 4, 64, 65, 65 }, /* 405 Mb */
-		[66] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS, 405000,
-			317200, 23, 23, 4, 66, 67, 67 }, /* 405 Mb */
-		[67] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS_HGI, 450000,
-			346400, 23, 23, 4, 66, 67, 67 }, /* 450 Mb */
+		[0] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 60,
+				0, 12, 0, 0 }, /* 6 Mb */
+		[1] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 90,
+				1, 18, 0, 1 }, /* 9 Mb */
+		[2] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 120,
+				2, 24, 2, 2 }, /* 12 Mb */
+		[3] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 180,
+				3, 36, 2, 3 }, /* 18 Mb */
+		[4] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 240,
+				4, 48, 4, 4 }, /* 24 Mb */
+		[5] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 360,
+				5, 72, 4, 5 }, /* 36 Mb */
+		[6] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 480,
+				6, 96, 4, 6 }, /* 48 Mb */
+		[7] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 540,
+				7, 108, 4, 7 }, /* 54 Mb */
+		[8] = { RC_HT_SDT_2040, WLAN_RC_PHY_HT_20_SS, 65,
+				0, 0, 0, 24 }, /* 6.5 Mb */
+		[9] = { RC_HT_SDT_20, WLAN_RC_PHY_HT_20_SS, 130,
+				1, 1, 2, 25 }, /* 13 Mb */
+		[10] = { RC_HT_SDT_20, WLAN_RC_PHY_HT_20_SS, 195,
+				2, 2, 2, 26 }, /* 19.5 Mb */
+		[11] = { RC_HT_SD_20, WLAN_RC_PHY_HT_20_SS, 260,
+				3, 3, 4, 27 }, /* 26 Mb */
+		[12] = { RC_HT_SD_20, WLAN_RC_PHY_HT_20_SS, 390,
+				4, 4, 4, 28 }, /* 39 Mb */
+		[13] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 520,
+				5, 5, 4, 29 }, /* 52 Mb */
+		[14] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 585,
+				6, 6, 4, 30 }, /* 58.5 Mb */
+		[15] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS_HGI, 722,
+				7, 7, 4, 31 }, /* 75 Mb */
+		[16] = { RC_INVALID, WLAN_RC_PHY_HT_20_DS, 130,
+				8, 8, 0, 32 }, /* 13 Mb */
+		[17] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 260,
+				9, 9, 2, 33 }, /* 26 Mb */
+		[18] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 390,
+				10, 10, 2, 34 }, /* 39 Mb */
+		[19] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 520,
+				11, 11, 4, 35 }, /* 52 Mb */
+		[20] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 780,
+				12, 12, 4, 36 }, /* 78 Mb */
+		[21] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 1040,
+				13, 13, 4, 37 }, /* 104 Mb */
+		[22] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 1170,
+				14, 14, 4, 38 }, /* 117 Mb */
+		[23] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS_HGI, 1444,
+				15, 15, 4, 39 }, /* 144.4 Mb */
+		[24] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 150,
+				0, 0, 0, 24 }, /* 13.5 Mb*/
+		[25] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 300,
+				1, 1, 2, 25 }, /* 27.0 Mb*/
+		[26] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 450,
+				2, 2, 2, 26 }, /* 40.5 Mb*/
+		[27] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 600,
+				3, 3, 4, 27 }, /* 54 Mb */
+		[28] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 900,
+				4, 4, 4, 28 }, /* 81 Mb */
+		[29] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 1200,
+				5, 5, 4, 29 }, /* 108 Mb */
+		[30] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 1350,
+				6, 6, 4, 30 }, /* 121.5 Mb*/
+		[31] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS_HGI, 1500,
+				7, 7, 4, 31 }, /* 150 Mb */
+		[32] = { RC_INVALID, WLAN_RC_PHY_HT_40_DS, 300,
+				8, 8, 0, 32 }, /* 27 Mb */
+		[33] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 600,
+				9, 9, 2, 33 }, /* 54 Mb */
+		[34] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 900,
+				10, 10, 2, 34 }, /* 81 Mb */
+		[35] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 1200,
+				11, 11, 4, 35 }, /* 108 Mb */
+		[36] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 1800,
+				12, 12, 4, 36 }, /* 162 Mb */
+		[37] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 2400,
+				13, 13, 4, 37 }, /* 216 Mb */
+		[38] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 2700,
+				14, 14, 4, 38 }, /* 243 Mb */
+		[39] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS_HGI, 3000,
+				15, 15, 4, 39 }, /* 300 Mb */
 	},
-	50,  /* probe interval */
-	WLAN_RC_HT_FLAG,  /* Phy rates allowed initially */
 };
 
 /* 4ms frame limit not used for NG mode.  The values filled
@@ -173,555 +117,131 @@
 	12, /* MCS start */
 	{
 		[0] = { RC_ALL, WLAN_RC_PHY_CCK, 1000,
-			900, 0, 2, 0, 0, 0, 0 }, /* 1 Mb */
+			0, 2, 0, 0 }, /* 1 Mb */
 		[1] = { RC_ALL, WLAN_RC_PHY_CCK, 2000,
-			1900, 1, 4, 1, 1, 1, 1 }, /* 2 Mb */
+			1, 4, 1, 1 }, /* 2 Mb */
 		[2] = { RC_ALL, WLAN_RC_PHY_CCK, 5500,
-			4900, 2, 11, 2, 2, 2, 2 }, /* 5.5 Mb */
+			2, 11, 2, 2 }, /* 5.5 Mb */
 		[3] = { RC_ALL, WLAN_RC_PHY_CCK, 11000,
-			8100, 3, 22, 3, 3, 3, 3 }, /* 11 Mb */
+			3, 22, 3, 3 }, /* 11 Mb */
 		[4] = { RC_INVALID, WLAN_RC_PHY_OFDM, 6000,
-			5400, 4, 12, 4, 4, 4, 4 }, /* 6 Mb */
+			4, 12, 4, 4 }, /* 6 Mb */
 		[5] = { RC_INVALID, WLAN_RC_PHY_OFDM, 9000,
-			7800, 5, 18, 4, 5, 5, 5 }, /* 9 Mb */
+			5, 18, 4, 5 }, /* 9 Mb */
 		[6] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 12000,
-			10100, 6, 24, 6, 6, 6, 6 }, /* 12 Mb */
+			6, 24, 6, 6 }, /* 12 Mb */
 		[7] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 18000,
-			14100, 7, 36, 6, 7, 7, 7 }, /* 18 Mb */
+			7, 36, 6, 7 }, /* 18 Mb */
 		[8] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 24000,
-			17700, 8, 48, 8, 8, 8, 8 }, /* 24 Mb */
+			8, 48, 8, 8 }, /* 24 Mb */
 		[9] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 36000,
-			23700, 9, 72, 8, 9, 9, 9 }, /* 36 Mb */
+			9, 72, 8, 9 }, /* 36 Mb */
 		[10] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 48000,
-			27400, 10, 96, 8, 10, 10, 10 }, /* 48 Mb */
+			10, 96, 8, 10 }, /* 48 Mb */
 		[11] = { RC_L_SDT, WLAN_RC_PHY_OFDM, 54000,
-			30900, 11, 108, 8, 11, 11, 11 }, /* 54 Mb */
+			11, 108, 8, 11 }, /* 54 Mb */
 		[12] = { RC_INVALID, WLAN_RC_PHY_HT_20_SS, 6500,
-			6400, 0, 0, 4, 42, 12, 42 }, /* 6.5 Mb */
+			0, 0, 4, 28 }, /* 6.5 Mb */
 		[13] = { RC_HT_SDT_20, WLAN_RC_PHY_HT_20_SS, 13000,
-			12700, 1, 1, 6, 43, 13, 43 }, /* 13 Mb */
+			1, 1, 6, 29 }, /* 13 Mb */
 		[14] = { RC_HT_SDT_20, WLAN_RC_PHY_HT_20_SS, 19500,
-			18800, 2, 2, 6, 44, 14, 44 }, /* 19.5 Mb*/
+			2, 2, 6, 30 }, /* 19.5 Mb*/
 		[15] = { RC_HT_SD_20, WLAN_RC_PHY_HT_20_SS, 26000,
-			25000, 3, 3, 8, 45, 15, 45 }, /* 26 Mb */
+			3, 3, 8, 31 }, /* 26 Mb */
 		[16] = { RC_HT_SD_20, WLAN_RC_PHY_HT_20_SS, 39000,
-			36700, 4, 4, 8, 46, 16, 46 }, /* 39 Mb */
+			4, 4, 8, 32 }, /* 39 Mb */
 		[17] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 52000,
-			48100, 5, 5, 8, 47, 17, 47 }, /* 52 Mb */
+			5, 5, 8, 33 }, /* 52 Mb */
 		[18] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 58500,
-			53500, 6, 6, 8, 48, 18, 48 }, /* 58.5 Mb */
-		[19] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS, 65000,
-			59000, 7, 7, 8, 49, 20, 50 }, /* 65 Mb */
-		[20] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS_HGI, 72200,
-			65400, 7, 7, 8, 49, 20, 50 }, /* 65 Mb*/
-		[21] = { RC_INVALID, WLAN_RC_PHY_HT_20_DS, 13000,
-			12700, 8, 8, 4, 51, 21, 51 }, /* 13 Mb */
-		[22] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 26000,
-			24800, 9, 9, 6, 52, 22, 52 }, /* 26 Mb */
-		[23] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 39000,
-			36600, 10, 10, 6, 53, 23, 53 }, /* 39 Mb */
-		[24] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 52000,
-			48100, 11, 11, 8, 54, 24, 54 }, /* 52 Mb */
-		[25] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 78000,
-			69500, 12, 12, 8, 55, 25, 55 }, /* 78 Mb */
-		[26] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 104000,
-			89500, 13, 13, 8, 56, 26, 56 }, /* 104 Mb */
-		[27] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 117000,
-			98900, 14, 14, 8, 57, 27, 57 }, /* 117 Mb */
-		[28] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 130000,
-			108300, 15, 15, 8, 58, 29, 59 }, /* 130 Mb */
-		[29] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS_HGI, 144400,
-			120000, 15, 15, 8, 58, 29, 59 }, /* 144.4 Mb */
-		[30] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 19500,
-			17400, 16, 16, 4, 60, 30, 60 }, /* 19.5 Mb */
-		[31] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 39000,
-			35100, 17, 17, 6, 61, 31, 61 }, /* 39 Mb */
-		[32] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 58500,
-			52600, 18, 18, 6, 62, 32, 62 }, /* 58.5 Mb */
-		[33] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 78000,
-			70400, 19, 19, 8, 63, 33, 63 }, /* 78 Mb */
-		[34] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS, 117000,
-			104900, 20, 20, 8, 64, 35, 65 }, /* 117 Mb */
-		[35] = {  RC_INVALID, WLAN_RC_PHY_HT_20_TS_HGI, 130000,
-			115800, 20, 20, 8, 64, 35, 65 }, /* 130 Mb */
-		[36] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS, 156000,
-			137200, 21, 21, 8, 66, 37, 67 }, /* 156 Mb */
-		[37] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS_HGI, 173300,
-			151100, 21, 21, 8, 66, 37, 67 }, /* 173.3 Mb */
-		[38] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS, 175500,
-			152800, 22, 22, 8, 68, 39, 69 }, /* 175.5 Mb */
-		[39] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS_HGI, 195000,
-			168400, 22, 22, 8, 68, 39, 69 }, /* 195 Mb */
-		[40] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS, 195000,
-			168400, 23, 23, 8, 70, 41, 71 }, /* 195 Mb */
-		[41] = {  RC_HT_T_20, WLAN_RC_PHY_HT_20_TS_HGI, 216700,
-			185000, 23, 23, 8, 70, 41, 71 }, /* 216.7 Mb */
-		[42] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 13500,
-			13200, 0, 0, 8, 42, 42, 42 }, /* 13.5 Mb */
-		[43] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 27500,
-			25900, 1, 1, 8, 43, 43, 43 }, /* 27.0 Mb */
-		[44] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 40500,
-			38600, 2, 2, 8, 44, 44, 44 }, /* 40.5 Mb */
-		[45] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 54000,
-			49800, 3, 3, 8, 45, 45, 45 }, /* 54 Mb */
-		[46] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 81500,
-			72200, 4, 4, 8, 46, 46, 46 }, /* 81 Mb */
-		[47] = { RC_HT_S_40 , WLAN_RC_PHY_HT_40_SS, 108000,
-			92900, 5, 5, 8, 47, 47, 47 }, /* 108 Mb */
-		[48] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 121500,
-			102700, 6, 6, 8, 48, 48, 48 }, /* 121.5 Mb */
-		[49] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 135000,
-			112000, 7, 7, 8, 49, 50, 50 }, /* 135 Mb */
-		[50] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS_HGI, 150000,
-			122000, 7, 7, 8, 49, 50, 50 }, /* 150 Mb */
-		[51] = { RC_INVALID, WLAN_RC_PHY_HT_40_DS, 27000,
-			25800, 8, 8, 8, 51, 51, 51 }, /* 27 Mb */
-		[52] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 54000,
-			49800, 9, 9, 8, 52, 52, 52 }, /* 54 Mb */
-		[53] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 81000,
-			71900, 10, 10, 8, 53, 53, 53 }, /* 81 Mb */
-		[54] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 108000,
-			92500, 11, 11, 8, 54, 54, 54 }, /* 108 Mb */
-		[55] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 162000,
-			130300, 12, 12, 8, 55, 55, 55 }, /* 162 Mb */
-		[56] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 216000,
-			162800, 13, 13, 8, 56, 56, 56 }, /* 216 Mb */
-		[57] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 243000,
-			178200, 14, 14, 8, 57, 57, 57 }, /* 243 Mb */
-		[58] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 270000,
-			192100, 15, 15, 8, 58, 59, 59 }, /* 270 Mb */
-		[59] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS_HGI, 300000,
-			207000, 15, 15, 8, 58, 59, 59 }, /* 300 Mb */
-		[60] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 40500,
-			36100, 16, 16, 8, 60, 60, 60 }, /* 40.5 Mb */
-		[61] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 81000,
-			72900, 17, 17, 8, 61, 61, 61 }, /* 81 Mb */
-		[62] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 121500,
-			108300, 18, 18, 8, 62, 62, 62 }, /* 121.5 Mb */
-		[63] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 162000,
-			142000, 19, 19, 8, 63, 63, 63 }, /* 162 Mb */
-		[64] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS, 243000,
-			205100, 20, 20, 8, 64, 65, 65 }, /* 243 Mb */
-		[65] = {  RC_INVALID, WLAN_RC_PHY_HT_40_TS_HGI, 270000,
-			224700, 20, 20, 8, 64, 65, 65 }, /* 270 Mb */
-		[66] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS, 324000,
-			263100, 21, 21, 8, 66, 67, 67 }, /* 324 Mb */
-		[67] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS_HGI, 360000,
-			288000, 21, 21, 8, 66, 67, 67 }, /* 360 Mb */
-		[68] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS, 364500,
-			290700, 22, 22, 8, 68, 69, 69 }, /* 364.5 Mb */
-		[69] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS_HGI, 405000,
-			317200, 22, 22, 8, 68, 69, 69 }, /* 405 Mb */
-		[70] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS, 405000,
-			317200, 23, 23, 8, 70, 71, 71 }, /* 405 Mb */
-		[71] = {  RC_HT_T_40, WLAN_RC_PHY_HT_40_TS_HGI, 450000,
-			346400, 23, 23, 8, 70, 71, 71 }, /* 450 Mb */
+			6, 6, 8, 34 }, /* 58.5 Mb */
+		[19] = { RC_HT_S_20, WLAN_RC_PHY_HT_20_SS_HGI, 72200,
+			7, 7, 8, 35 }, /* 65 Mb*/
+		[20] = { RC_INVALID, WLAN_RC_PHY_HT_20_DS, 13000,
+			8, 8, 4, 36 }, /* 13 Mb */
+		[21] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 26000,
+			9, 9, 6, 37 }, /* 26 Mb */
+		[22] = { RC_HT_T_20, WLAN_RC_PHY_HT_20_DS, 39000,
+			10, 10, 6, 38 }, /* 39 Mb */
+		[23] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 52000,
+			11, 11, 8, 39 }, /* 52 Mb */
+		[24] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 78000,
+			12, 12, 8, 40 }, /* 78 Mb */
+		[25] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 104000,
+			13, 13, 8, 41 }, /* 104 Mb */
+		[26] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS, 117000,
+			14, 14, 8, 42 }, /* 117 Mb */
+		[27] = { RC_HT_DT_20, WLAN_RC_PHY_HT_20_DS_HGI, 144400,
+			15, 15, 8, 43 }, /* 144.4 Mb */
+		[28] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 13500,
+			0, 0, 8, 28 }, /* 13.5 Mb */
+		[29] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 27500,
+			1, 1, 8, 29 }, /* 27.0 Mb */
+		[30] = { RC_HT_SDT_40, WLAN_RC_PHY_HT_40_SS, 40500,
+			2, 2, 8, 30 }, /* 40.5 Mb */
+		[31] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 54000,
+			3, 3, 8, 31 }, /* 54 Mb */
+		[32] = { RC_HT_SD_40, WLAN_RC_PHY_HT_40_SS, 81500,
+			4, 4, 8, 32 }, /* 81 Mb */
+		[33] = { RC_HT_S_40 , WLAN_RC_PHY_HT_40_SS, 108000,
+			5, 5, 8, 33 }, /* 108 Mb */
+		[34] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS, 121500,
+			6, 6, 8, 34 }, /* 121.5 Mb */
+		[35] = { RC_HT_S_40, WLAN_RC_PHY_HT_40_SS_HGI, 150000,
+			7, 7, 8, 35 }, /* 150 Mb */
+		[36] = { RC_INVALID, WLAN_RC_PHY_HT_40_DS, 27000,
+			8, 8, 8, 36 }, /* 27 Mb */
+		[37] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 54000,
+			9, 9, 8, 37 }, /* 54 Mb */
+		[38] = { RC_HT_T_40, WLAN_RC_PHY_HT_40_DS, 81000,
+			10, 10, 8, 38 }, /* 81 Mb */
+		[39] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 108000,
+			11, 11, 8, 39 }, /* 108 Mb */
+		[40] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 162000,
+			12, 12, 8, 40 }, /* 162 Mb */
+		[41] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 216000,
+			13, 13, 8, 41 }, /* 216 Mb */
+		[42] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS, 243000,
+			14, 14, 8, 42 }, /* 243 Mb */
+		[43] = { RC_HT_DT_40, WLAN_RC_PHY_HT_40_DS_HGI, 300000,
+			15, 15, 8, 43 }, /* 300 Mb */
 	},
-	50,  /* probe interval */
-	WLAN_RC_HT_FLAG,  /* Phy rates allowed initially */
 };
 
-static const struct ath_rate_table ar5416_11a_ratetable = {
-	8,
-	0,
-	{
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 6000, /* 6 Mb */
-			5400, 0, 12, 0},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 9000, /* 9 Mb */
-			7800,  1, 18, 0},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 12000, /* 12 Mb */
-			10000, 2, 24, 2},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 18000, /* 18 Mb */
-			13900, 3, 36, 2},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 24000, /* 24 Mb */
-			17300, 4, 48, 4},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 36000, /* 36 Mb */
-			23000, 5, 72, 4},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 48000, /* 48 Mb */
-			27400, 6, 96, 4},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 54000, /* 54 Mb */
-			29300, 7, 108, 4},
-	},
-	50,  /* probe interval */
-	0,   /* Phy rates allowed initially */
-};
-
-static const struct ath_rate_table ar5416_11g_ratetable = {
-	12,
-	0,
-	{
-		{ RC_L_SDT, WLAN_RC_PHY_CCK, 1000, /* 1 Mb */
-			900, 0, 2, 0},
-		{ RC_L_SDT, WLAN_RC_PHY_CCK, 2000, /* 2 Mb */
-			1900, 1, 4, 1},
-		{ RC_L_SDT, WLAN_RC_PHY_CCK, 5500, /* 5.5 Mb */
-			4900, 2, 11, 2},
-		{ RC_L_SDT, WLAN_RC_PHY_CCK, 11000, /* 11 Mb */
-			8100, 3, 22, 3},
-		{ RC_INVALID, WLAN_RC_PHY_OFDM, 6000, /* 6 Mb */
-			5400, 4, 12, 4},
-		{ RC_INVALID, WLAN_RC_PHY_OFDM, 9000, /* 9 Mb */
-			7800, 5, 18, 4},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 12000, /* 12 Mb */
-			10000, 6, 24, 6},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 18000, /* 18 Mb */
-			13900, 7, 36, 6},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 24000, /* 24 Mb */
-			17300, 8, 48, 8},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 36000, /* 36 Mb */
-			23000, 9, 72, 8},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 48000, /* 48 Mb */
-			27400, 10, 96, 8},
-		{ RC_L_SDT, WLAN_RC_PHY_OFDM, 54000, /* 54 Mb */
-			29300, 11, 108, 8},
-	},
-	50,  /* probe interval */
-	0,   /* Phy rates allowed initially */
-};
+u8 rssi_limit_40 [] = {12, 14, 15, 17, 19, 20, 22, 24, 27, 28};
+u8 rssi_limit_20 [] = {12, 14, 17, 19, 24, 27, 28};
 
 static int ath_rc_get_rateindex(const struct ath_rate_table *rate_table,
 				struct ieee80211_tx_rate *rate)
 {
-	int rix = 0, i = 0;
-	static const int mcs_rix_off[] = { 7, 15, 20, 21, 22, 23 };
+	int rix = 0;
 
 	if (!(rate->flags & IEEE80211_TX_RC_MCS))
 		return rate->idx;
 
-	while (i < ARRAY_SIZE(mcs_rix_off) && rate->idx > mcs_rix_off[i]) {
-		rix++; i++;
-	}
-
 	rix += rate->idx + rate_table->mcs_start;
 
-	if ((rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) &&
-	    (rate->flags & IEEE80211_TX_RC_SHORT_GI))
+	if (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
 		rix = rate_table->info[rix].ht_index;
-	else if (rate->flags & IEEE80211_TX_RC_SHORT_GI)
-		rix = rate_table->info[rix].sgi_index;
-	else if (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
-		rix = rate_table->info[rix].cw40index;
 
 	return rix;
 }
 
-static void ath_rc_sort_validrates(const struct ath_rate_table *rate_table,
-				   struct ath_rate_priv *ath_rc_priv)
-{
-	u8 i, j, idx, idx_next;
-
-	for (i = ath_rc_priv->max_valid_rate - 1; i > 0; i--) {
-		for (j = 0; j <= i-1; j++) {
-			idx = ath_rc_priv->valid_rate_index[j];
-			idx_next = ath_rc_priv->valid_rate_index[j+1];
-
-			if (rate_table->info[idx].ratekbps >
-				rate_table->info[idx_next].ratekbps) {
-				ath_rc_priv->valid_rate_index[j] = idx_next;
-				ath_rc_priv->valid_rate_index[j+1] = idx;
-			}
-		}
-	}
-}
-
-static void ath_rc_init_valid_rate_idx(struct ath_rate_priv *ath_rc_priv)
-{
-	u8 i;
-
-	for (i = 0; i < ath_rc_priv->rate_table_size; i++)
-		ath_rc_priv->valid_rate_index[i] = 0;
-}
-
-static inline void ath_rc_set_valid_rate_idx(struct ath_rate_priv *ath_rc_priv,
-					   u8 index, int valid_tx_rate)
-{
-	BUG_ON(index > ath_rc_priv->rate_table_size);
-	ath_rc_priv->valid_rate_index[index] = !!valid_tx_rate;
-}
-
-static inline
-int ath_rc_get_nextvalid_txrate(const struct ath_rate_table *rate_table,
-				struct ath_rate_priv *ath_rc_priv,
-				u8 cur_valid_txrate,
-				u8 *next_idx)
-{
-	u8 i;
-
-	for (i = 0; i < ath_rc_priv->max_valid_rate - 1; i++) {
-		if (ath_rc_priv->valid_rate_index[i] == cur_valid_txrate) {
-			*next_idx = ath_rc_priv->valid_rate_index[i+1];
-			return 1;
-		}
-	}
-
-	/* No more valid rates */
-	*next_idx = 0;
-
-	return 0;
-}
-
-/* Return true only for single stream */
-
-static int ath_rc_valid_phyrate(u32 phy, u32 capflag, int ignore_cw)
-{
-	if (WLAN_RC_PHY_HT(phy) && !(capflag & WLAN_RC_HT_FLAG))
-		return 0;
-	if (WLAN_RC_PHY_DS(phy) && !(capflag & WLAN_RC_DS_FLAG))
-		return 0;
-	if (WLAN_RC_PHY_TS(phy) && !(capflag & WLAN_RC_TS_FLAG))
-		return 0;
-	if (WLAN_RC_PHY_SGI(phy) && !(capflag & WLAN_RC_SGI_FLAG))
-		return 0;
-	if (!ignore_cw && WLAN_RC_PHY_HT(phy))
-		if (WLAN_RC_PHY_40(phy) && !(capflag & WLAN_RC_40_FLAG))
-			return 0;
-	return 1;
-}
-
-static inline int
-ath_rc_get_lower_rix(const struct ath_rate_table *rate_table,
-		     struct ath_rate_priv *ath_rc_priv,
-		     u8 cur_valid_txrate, u8 *next_idx)
-{
-	int8_t i;
-
-	for (i = 1; i < ath_rc_priv->max_valid_rate ; i++) {
-		if (ath_rc_priv->valid_rate_index[i] == cur_valid_txrate) {
-			*next_idx = ath_rc_priv->valid_rate_index[i-1];
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-static u8 ath_rc_init_validrates(struct ath_rate_priv *ath_rc_priv,
-				 const struct ath_rate_table *rate_table,
-				 u32 capflag)
-{
-	u8 i, hi = 0;
-
-	for (i = 0; i < rate_table->rate_cnt; i++) {
-		if (rate_table->info[i].rate_flags & RC_LEGACY) {
-			u32 phy = rate_table->info[i].phy;
-			u8 valid_rate_count = 0;
-
-			if (!ath_rc_valid_phyrate(phy, capflag, 0))
-				continue;
-
-			valid_rate_count = ath_rc_priv->valid_phy_ratecnt[phy];
-
-			ath_rc_priv->valid_phy_rateidx[phy][valid_rate_count] = i;
-			ath_rc_priv->valid_phy_ratecnt[phy] += 1;
-			ath_rc_set_valid_rate_idx(ath_rc_priv, i, 1);
-			hi = i;
-		}
-	}
-
-	return hi;
-}
-
-static u8 ath_rc_setvalid_rates(struct ath_rate_priv *ath_rc_priv,
-				const struct ath_rate_table *rate_table,
-				struct ath_rateset *rateset,
-				u32 capflag)
-{
-	u8 i, j, hi = 0;
-
-	/* Use intersection of working rates and valid rates */
-	for (i = 0; i < rateset->rs_nrates; i++) {
-		for (j = 0; j < rate_table->rate_cnt; j++) {
-			u32 phy = rate_table->info[j].phy;
-			u16 rate_flags = rate_table->info[j].rate_flags;
-			u8 rate = rateset->rs_rates[i];
-			u8 dot11rate = rate_table->info[j].dot11rate;
-
-			/* We allow a rate only if its valid and the
-			 * capflag matches one of the validity
-			 * (VALID/VALID_20/VALID_40) flags */
-
-			if ((rate == dot11rate) &&
-			    (rate_flags & WLAN_RC_CAP_MODE(capflag)) ==
-			    WLAN_RC_CAP_MODE(capflag) &&
-			    (rate_flags & WLAN_RC_CAP_STREAM(capflag)) &&
-			    !WLAN_RC_PHY_HT(phy)) {
-				u8 valid_rate_count = 0;
-
-				if (!ath_rc_valid_phyrate(phy, capflag, 0))
-					continue;
-
-				valid_rate_count =
-					ath_rc_priv->valid_phy_ratecnt[phy];
-
-				ath_rc_priv->valid_phy_rateidx[phy]
-					[valid_rate_count] = j;
-				ath_rc_priv->valid_phy_ratecnt[phy] += 1;
-				ath_rc_set_valid_rate_idx(ath_rc_priv, j, 1);
-				hi = max(hi, j);
-			}
-		}
-	}
-
-	return hi;
-}
-
-static u8 ath_rc_setvalid_htrates(struct ath_rate_priv *ath_rc_priv,
-				  const struct ath_rate_table *rate_table,
-				  u8 *mcs_set, u32 capflag)
-{
-	struct ath_rateset *rateset = (struct ath_rateset *)mcs_set;
-
-	u8 i, j, hi = 0;
-
-	/* Use intersection of working rates and valid rates */
-	for (i = 0; i < rateset->rs_nrates; i++) {
-		for (j = 0; j < rate_table->rate_cnt; j++) {
-			u32 phy = rate_table->info[j].phy;
-			u16 rate_flags = rate_table->info[j].rate_flags;
-			u8 rate = rateset->rs_rates[i];
-			u8 dot11rate = rate_table->info[j].dot11rate;
-
-			if ((rate != dot11rate) || !WLAN_RC_PHY_HT(phy) ||
-			    !(rate_flags & WLAN_RC_CAP_STREAM(capflag)) ||
-			    !WLAN_RC_PHY_HT_VALID(rate_flags, capflag))
-				continue;
-
-			if (!ath_rc_valid_phyrate(phy, capflag, 0))
-				continue;
-
-			ath_rc_priv->valid_phy_rateidx[phy]
-				[ath_rc_priv->valid_phy_ratecnt[phy]] = j;
-			ath_rc_priv->valid_phy_ratecnt[phy] += 1;
-			ath_rc_set_valid_rate_idx(ath_rc_priv, j, 1);
-			hi = max(hi, j);
-		}
-	}
-
-	return hi;
-}
-
-/* Finds the highest rate index we can use */
-static u8 ath_rc_get_highest_rix(struct ath_softc *sc,
-			         struct ath_rate_priv *ath_rc_priv,
-				 const struct ath_rate_table *rate_table,
-				 int *is_probing,
-				 bool legacy)
-{
-	u32 best_thruput, this_thruput, now_msec;
-	u8 rate, next_rate, best_rate, maxindex, minindex;
-	int8_t index = 0;
-
-	now_msec = jiffies_to_msecs(jiffies);
-	*is_probing = 0;
-	best_thruput = 0;
-	maxindex = ath_rc_priv->max_valid_rate-1;
-	minindex = 0;
-	best_rate = minindex;
-
-	/*
-	 * Try the higher rate first. It will reduce memory moving time
-	 * if we have very good channel characteristics.
-	 */
-	for (index = maxindex; index >= minindex ; index--) {
-		u8 per_thres;
-
-		rate = ath_rc_priv->valid_rate_index[index];
-		if (legacy && !(rate_table->info[rate].rate_flags & RC_LEGACY))
-			continue;
-		if (rate > ath_rc_priv->rate_max_phy)
-			continue;
-
-		/*
-		 * For TCP the average collision rate is around 11%,
-		 * so we ignore PERs less than this.  This is to
-		 * prevent the rate we are currently using (whose
-		 * PER might be in the 10-15 range because of TCP
-		 * collisions) looking worse than the next lower
-		 * rate whose PER has decayed close to 0.  If we
-		 * used to next lower rate, its PER would grow to
-		 * 10-15 and we would be worse off then staying
-		 * at the current rate.
-		 */
-		per_thres = ath_rc_priv->per[rate];
-		if (per_thres < 12)
-			per_thres = 12;
-
-		this_thruput = rate_table->info[rate].user_ratekbps *
-			(100 - per_thres);
-
-		if (best_thruput <= this_thruput) {
-			best_thruput = this_thruput;
-			best_rate    = rate;
-		}
-	}
-
-	rate = best_rate;
-
-	/*
-	 * Must check the actual rate (ratekbps) to account for
-	 * non-monoticity of 11g's rate table
-	 */
-
-	if (rate >= ath_rc_priv->rate_max_phy) {
-		rate = ath_rc_priv->rate_max_phy;
-
-		/* Probe the next allowed phy state */
-		if (ath_rc_get_nextvalid_txrate(rate_table,
-					ath_rc_priv, rate, &next_rate) &&
-		    (now_msec - ath_rc_priv->probe_time >
-		     rate_table->probe_interval) &&
-		    (ath_rc_priv->hw_maxretry_pktcnt >= 1)) {
-			rate = next_rate;
-			ath_rc_priv->probe_rate = rate;
-			ath_rc_priv->probe_time = now_msec;
-			ath_rc_priv->hw_maxretry_pktcnt = 0;
-			*is_probing = 1;
-		}
-	}
-
-	if (rate > (ath_rc_priv->rate_table_size - 1))
-		rate = ath_rc_priv->rate_table_size - 1;
-
-	if (RC_TS_ONLY(rate_table->info[rate].rate_flags) &&
-	    (ath_rc_priv->ht_cap & WLAN_RC_TS_FLAG))
-		return rate;
-
-	if (RC_DS_OR_LATER(rate_table->info[rate].rate_flags) &&
-	    (ath_rc_priv->ht_cap & (WLAN_RC_DS_FLAG | WLAN_RC_TS_FLAG)))
-		return rate;
-
-	if (RC_SS_OR_LEGACY(rate_table->info[rate].rate_flags))
-		return rate;
-
-	/* This should not happen */
-	WARN_ON(1);
-
-	rate = ath_rc_priv->valid_rate_index[0];
-
-	return rate;
-}
-
-static void ath_rc_rate_set_series(const struct ath_rate_table *rate_table,
-				   struct ieee80211_tx_rate *rate,
+static void ath_rc_rate_set_series(struct ieee80211_tx_rate *rate,
 				   struct ieee80211_tx_rate_control *txrc,
-				   u8 tries, u8 rix, int rtsctsenable)
+				   u8 tries, u8 rix, u8 flags, int rtsctsenable)
 {
 	rate->count = tries;
-	rate->idx = rate_table->info[rix].ratecode;
+	rate->idx = rix;
 
 	if (txrc->short_preamble)
 		rate->flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;
 	if (txrc->rts || rtsctsenable)
 		rate->flags |= IEEE80211_TX_RC_USE_RTS_CTS;
 
-	if (WLAN_RC_PHY_HT(rate_table->info[rix].phy)) {
-		rate->flags |= IEEE80211_TX_RC_MCS;
-		if (WLAN_RC_PHY_40(rate_table->info[rix].phy) &&
-		    conf_is_ht40(&txrc->hw->conf))
-			rate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
-		if (WLAN_RC_PHY_SGI(rate_table->info[rix].phy))
-			rate->flags |= IEEE80211_TX_RC_SHORT_GI;
-	}
+	rate->flags |= flags;
+	if ((flags & IEEE80211_TX_RC_MCS) && (flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+				&& !conf_is_ht40(&txrc->hw->conf))
+		rate->flags &= ~IEEE80211_TX_RC_40_MHZ_WIDTH;
 }
 
 static void ath_rc_rate_set_rtscts(struct ath_softc *sc,
@@ -729,15 +249,11 @@
 				   struct ieee80211_tx_info *tx_info)
 {
 	struct ieee80211_tx_rate *rates = tx_info->control.rates;
-	int i = 0, rix = 0, cix, enable_g_protection = 0;
+	int rix = 0, cix, enable_g_protection = 0;
 
 	/* get the cix for the lowest valid rix */
-	for (i = 3; i >= 0; i--) {
-		if (rates[i].count && (rates[i].idx >= 0)) {
-			rix = ath_rc_get_rateindex(rate_table, &rates[i]);
-			break;
-		}
-	}
+	rix = ath_rc_get_rateindex(rate_table, &rates[0]);
+
 	cix = rate_table->info[rix].ctrl_rate;
 
 	/* All protection frames are transmited at 2Mb/s for 802.11g,
@@ -770,29 +286,89 @@
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_tx_rate *rates = tx_info->control.rates;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	__le16 fc = hdr->frame_control;
-	u8 try_per_rate, i = 0, rix, high_rix;
-	int is_probe = 0;
+	int i, nf, rssi, rateset_index, rate_index;
+	struct rc_tx_rates *best_rate;
+	struct ath_rateset *rateset;
+	u16 rc_counter;
 
 	if (rate_control_send_low(sta, priv_sta, txrc))
 		return;
 
 	/*
-	 * For Multi Rate Retry we use a different number of
-	 * retry attempt counts. This ends up looking like this:
-	 *
-	 * MRR[0] = 4
-	 * MRR[1] = 4
-	 * MRR[2] = 4
-	 * MRR[3] = 8
+	 * Disable Multi Rate Retry and only try once for each packet, by zhfch
 	 *
+	 * MRR[0] = 1
+	 * MRR[1] = MRR[2] = MRR[3] = 0
 	 */
-	try_per_rate = 4;
-
 	rate_table = ath_rc_priv->rate_table;
-	rix = ath_rc_get_highest_rix(sc, ath_rc_priv, rate_table,
-				     &is_probe, false);
-	high_rix = rix;
+	rssi = ath_rc_priv->current_rssi;
+
+	if (!!(sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)){
+		if (rssi < rssi_limit_40[0])
+			rateset_index = 0;
+		else if (rssi > rssi_limit_40[9])
+			rateset_index = 10;
+		else {
+			for (i = 1 ; i < 10 ; i++){
+				if (rssi < rssi_limit_40[i]){
+					rateset_index = i;
+					break;
+				}
+			}
+		}
+	} else {
+		if (rssi < rssi_limit_20[0])
+			rateset_index = 0;
+		else if (rssi > rssi_limit_20[6])
+			rateset_index = 7;
+		else {
+			for (i = 1 ; i < 7 ; i++){
+				if (rssi < rssi_limit_20[i]){
+					rateset_index = i;
+					break;
+				}
+			}
+		}
+	}
+
+	rateset = &ath_rc_priv->rssi_rates[rateset_index];
+	rate_index = rateset->current_rate;
+	best_rate = &rateset->rs_rates[rate_index];
+	nf = best_rate->current_nf;
+	/* 7(2^7=128) stands for the number of frames in a group, by zhfch */
+	rc_counter = rateset->rc_count >> 6;
+	if ((rc_counter & 0x1C) == 0x1C){
+		/* need to probe */
+		rc_counter = rc_counter & 0x3;
+		if (rc_counter == 0){
+			/* probe the higher rate */
+			if (rateset->current_rate > 0){
+				if (!rateset->rs_rates[rateset->current_rate - 1].disable ||
+						time_after(jiffies, rateset->rs_rates[rateset->current_rate - 1].disabletime + HZ * 10)){
+					rate_index = rateset->current_rate - 1;
+					best_rate = &rateset->rs_rates[rate_index];
+					nf = best_rate->current_nf;
+					best_rate->disable = false;
+				}
+			}
+		}
+		else if (rc_counter == 1 && best_rate->need_probe){
+			/* probe the lower rate */
+			if (rateset->current_rate < rateset->rs_nrates - 1){
+				rate_index = rateset->current_rate + 1;
+				best_rate = &rateset->rs_rates[rate_index];
+				nf = best_rate->current_nf;
+			}
+		}
+		else if (rc_counter == 2 && best_rate->need_probe){
+			if (nf > 1)
+				nf--;
+		}
+		else if (rc_counter == 3){
+			if (nf < 32)
+				nf++;
+		}
+	}
 
 	/*
 	 * If we're in HT mode and both us and our peer supports LDPC.
@@ -807,379 +383,156 @@
 	    (sta->ht_cap.cap & IEEE80211_HT_CAP_TX_STBC))
 		tx_info->flags |= (1 << IEEE80211_TX_CTL_STBC_SHIFT);
 
-	if (is_probe) {
-		/* set one try for probe rates. For the
-		 * probes don't enable rts */
-		ath_rc_rate_set_series(rate_table, &rates[i++], txrc,
-				       1, rix, 0);
-
-		/* Get the next tried/allowed rate. No RTS for the next series
-		 * after the probe rate
-		 */
-		ath_rc_get_lower_rix(rate_table, ath_rc_priv, rix, &rix);
-		ath_rc_rate_set_series(rate_table, &rates[i++], txrc,
-				       try_per_rate, rix, 0);
-
-		tx_info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
-	} else {
-		/* Set the chosen rate. No RTS for first series entry. */
-		ath_rc_rate_set_series(rate_table, &rates[i++], txrc,
-				       try_per_rate, rix, 0);
+	if (WARN_ON_ONCE(rate_index < 0)){
+		rate_index = 0;
+		best_rate = &rateset->rs_rates[rate_index];
 	}
-
-	/* Fill in the other rates for multirate retry */
-	for ( ; i < 3; i++) {
-
-		ath_rc_get_lower_rix(rate_table, ath_rc_priv, rix, &rix);
-		/* All other rates in the series have RTS enabled */
-		ath_rc_rate_set_series(rate_table, &rates[i], txrc,
-				       try_per_rate, rix, 1);
+	else if (WARN_ON_ONCE(rate_index >= rateset->rs_nrates)){
+		rate_index = rateset->rs_nrates - 1;
+		best_rate = &rateset->rs_rates[rate_index];
 	}
-
-	/* Use twice the number of tries for the last MRR segment. */
-	try_per_rate = 8;
-
-	/*
-	 * Use a legacy rate as last retry to ensure that the frame
-	 * is tried in both MCS and legacy rates.
-	 */
-	if ((rates[2].flags & IEEE80211_TX_RC_MCS) &&
-	    (!(tx_info->flags & IEEE80211_TX_CTL_AMPDU) ||
-	    (ath_rc_priv->per[high_rix] > 45)))
-		rix = ath_rc_get_highest_rix(sc, ath_rc_priv, rate_table,
-				&is_probe, true);
-	else
-		ath_rc_get_lower_rix(rate_table, ath_rc_priv, rix, &rix);
-
-	/* All other rates in the series have RTS enabled */
-	ath_rc_rate_set_series(rate_table, &rates[i], txrc,
-			       try_per_rate, rix, 1);
-	/*
-	 * NB:Change rate series to enable aggregation when operating
-	 * at lower MCS rates. When first rate in series is MCS2
-	 * in HT40 @ 2.4GHz, series should look like:
-	 *
-	 * {MCS2, MCS1, MCS0, MCS0}.
-	 *
-	 * When first rate in series is MCS3 in HT20 @ 2.4GHz, series should
-	 * look like:
-	 *
-	 * {MCS3, MCS2, MCS1, MCS1}
-	 *
-	 * So, set fourth rate in series to be same as third one for
-	 * above conditions.
-	 */
-	if ((sc->hw->conf.channel->band == IEEE80211_BAND_2GHZ) &&
-	    (conf_is_ht(&sc->hw->conf))) {
-		u8 dot11rate = rate_table->info[rix].dot11rate;
-		u8 phy = rate_table->info[rix].phy;
-		if (i == 4 &&
-		    ((dot11rate == 2 && phy == WLAN_RC_PHY_HT_40_SS) ||
-		     (dot11rate == 3 && phy == WLAN_RC_PHY_HT_20_SS))) {
-			rates[3].idx = rates[2].idx;
-			rates[3].flags = rates[2].flags;
-		}
+	if (WARN_ON_ONCE(nf < 1)){
+		nf = 1;
 	}
-
-	/*
-	 * Force hardware to use computed duration for next
-	 * fragment by disabling multi-rate retry, which
-	 * updates duration based on the multi-rate duration table.
-	 *
-	 * FIXME: Fix duration
-	 */
-	if (ieee80211_has_morefrags(fc) ||
-	    (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG)) {
-		rates[1].count = rates[2].count = rates[3].count = 0;
-		rates[1].idx = rates[2].idx = rates[3].idx = 0;
-		rates[0].count = ATH_TXMAXTRY;
+	else if (WARN_ON_ONCE(nf > 32)){
+		nf = 32;
 	}
 
-	/* Setup RTS/CTS */
-	ath_rc_rate_set_rtscts(sc, rate_table, tx_info);
-}
-
-static void ath_rc_update_per(struct ath_softc *sc,
-			      const struct ath_rate_table *rate_table,
-			      struct ath_rate_priv *ath_rc_priv,
-				  struct ieee80211_tx_info *tx_info,
-			      int tx_rate, int xretries, int retries,
-			      u32 now_msec)
-{
-	int count, n_bad_frames;
-	u8 last_per;
-	static const u32 nretry_to_per_lookup[10] = {
-		100 * 0 / 1,
-		100 * 1 / 4,
-		100 * 1 / 2,
-		100 * 3 / 4,
-		100 * 4 / 5,
-		100 * 5 / 6,
-		100 * 6 / 7,
-		100 * 7 / 8,
-		100 * 8 / 9,
-		100 * 9 / 10
-	};
-
-	last_per = ath_rc_priv->per[tx_rate];
-	n_bad_frames = tx_info->status.ampdu_len - tx_info->status.ampdu_ack_len;
+	ath_rc_rate_set_series(&rates[0], txrc, 1, best_rate->idx, best_rate->flags, 0);
+	rates[1].count = rates[2].count = rates[3].count = 0;
+	rates[1].idx = rates[2].idx = rates[3].idx = 0;
 
-	if (xretries) {
-		if (xretries == 1) {
-			ath_rc_priv->per[tx_rate] += 30;
-			if (ath_rc_priv->per[tx_rate] > 100)
-				ath_rc_priv->per[tx_rate] = 100;
-		} else {
-			/* xretries == 2 */
-			count = ARRAY_SIZE(nretry_to_per_lookup);
-			if (retries >= count)
-				retries = count - 1;
-
-			/* new_PER = 7/8*old_PER + 1/8*(currentPER) */
-			ath_rc_priv->per[tx_rate] =
-				(u8)(last_per - (last_per >> 3) + (100 >> 3));
-		}
-
-		/* xretries == 1 or 2 */
-
-		if (ath_rc_priv->probe_rate == tx_rate)
-			ath_rc_priv->probe_rate = 0;
-
-	} else { /* xretries == 0 */
-		count = ARRAY_SIZE(nretry_to_per_lookup);
-		if (retries >= count)
-			retries = count - 1;
-
-		if (n_bad_frames) {
-			/* new_PER = 7/8*old_PER + 1/8*(currentPER)
-			 * Assuming that n_frames is not 0.  The current PER
-			 * from the retries is 100 * retries / (retries+1),
-			 * since the first retries attempts failed, and the
-			 * next one worked.  For the one that worked,
-			 * n_bad_frames subframes out of n_frames wored,
-			 * so the PER for that part is
-			 * 100 * n_bad_frames / n_frames, and it contributes
-			 * 100 * n_bad_frames / (n_frames * (retries+1)) to
-			 * the above PER.  The expression below is a
-			 * simplified version of the sum of these two terms.
-			 */
-			if (tx_info->status.ampdu_len > 0) {
-				int n_frames, n_bad_tries;
-				u8 cur_per, new_per;
-
-				n_bad_tries = retries * tx_info->status.ampdu_len +
-					n_bad_frames;
-				n_frames = tx_info->status.ampdu_len * (retries + 1);
-				cur_per = (100 * n_bad_tries / n_frames) >> 3;
-				new_per = (u8)(last_per - (last_per >> 3) + cur_per);
-				ath_rc_priv->per[tx_rate] = new_per;
-			}
-		} else {
-			ath_rc_priv->per[tx_rate] =
-				(u8)(last_per - (last_per >> 3) +
-				     (nretry_to_per_lookup[retries] >> 3));
-		}
+	tx_info->control.try_limit = 4;
+	tx_info->control.rateset_index = rateset_index;
+	tx_info->control.rate_index = rate_index;
+	tx_info->control.nframes = nf;
 
-
-		/*
-		 * If we got at most one retry then increase the max rate if
-		 * this was a probe.  Otherwise, ignore the probe.
-		 */
-		if (ath_rc_priv->probe_rate && ath_rc_priv->probe_rate == tx_rate) {
-			if (retries > 0 || 2 * n_bad_frames > tx_info->status.ampdu_len) {
-				/*
-				 * Since we probed with just a single attempt,
-				 * any retries means the probe failed.  Also,
-				 * if the attempt worked, but more than half
-				 * the subframes were bad then also consider
-				 * the probe a failure.
-				 */
-				ath_rc_priv->probe_rate = 0;
-			} else {
-				u8 probe_rate = 0;
-
-				ath_rc_priv->rate_max_phy =
-					ath_rc_priv->probe_rate;
-				probe_rate = ath_rc_priv->probe_rate;
-
-				if (ath_rc_priv->per[probe_rate] > 30)
-					ath_rc_priv->per[probe_rate] = 20;
-
-				ath_rc_priv->probe_rate = 0;
-
-				/*
-				 * Since this probe succeeded, we allow the next
-				 * probe twice as soon.  This allows the maxRate
-				 * to move up faster if the probes are
-				 * successful.
-				 */
-				ath_rc_priv->probe_time =
-					now_msec - rate_table->probe_interval / 2;
-			}
-		}
-
-		if (retries > 0) {
-			/*
-			 * Don't update anything.  We don't know if
-			 * this was because of collisions or poor signal.
-			 */
-			ath_rc_priv->hw_maxretry_pktcnt = 0;
-		} else {
-			/*
-			 * It worked with no retries. First ignore bogus (small)
-			 * rssi_ack values.
-			 */
-			if (tx_rate == ath_rc_priv->rate_max_phy &&
-			    ath_rc_priv->hw_maxretry_pktcnt < 255) {
-				ath_rc_priv->hw_maxretry_pktcnt++;
-			}
-
-		}
-	}
+	/* Setup RTS/CTS */
+	ath_rc_rate_set_rtscts(sc, rate_table, tx_info);
 }
 
-static void ath_debug_stat_retries(struct ath_rate_priv *rc, int rix,
-				   int xretries, int retries, u8 per)
+static void ath_debug_stat(struct ath_rate_priv *rc, int rix,
+				   int nf, int ok, int bad)
 {
-	struct ath_rc_stats *stats = &rc->rcstats[rix];
+	struct ath_rc_stats *stats = &rc->rcstats[rix][nf];
 
-	stats->xretries += xretries;
-	stats->retries += retries;
-	stats->per = per;
+	stats->success += ok;
+	stats->fail += bad;
 }
 
-/* Update PER, RSSI and whatever else that the code thinks it is doing.
-   If you can make sense of all this, you really need to go out more. */
-
-static void ath_rc_update_ht(struct ath_softc *sc,
-			     struct ath_rate_priv *ath_rc_priv,
-			     struct ieee80211_tx_info *tx_info,
-			     int tx_rate, int xretries, int retries)
+static void ath_rc_tx_status(struct ath_softc *sc, struct ath_rate_priv *ath_rc_priv,
+			     struct ieee80211_tx_info *tx_info, int tx_status)
 {
-	u32 now_msec = jiffies_to_msecs(jiffies);
-	int rate;
-	u8 last_per;
-	const struct ath_rate_table *rate_table = ath_rc_priv->rate_table;
-	int size = ath_rc_priv->rate_table_size;
-
-	if ((tx_rate < 0) || (tx_rate > rate_table->rate_cnt))
-		return;
-
-	last_per = ath_rc_priv->per[tx_rate];
+	const struct ath_rate_table *rate_table = ath_rc_priv->rate_table;;
 
-	/* Update PER first */
-	ath_rc_update_per(sc, rate_table, ath_rc_priv,
-			  tx_info, tx_rate, xretries,
-			  retries, now_msec);
-
-	/*
-	 * If this rate looks bad (high PER) then stop using it for
-	 * a while (except if we are probing).
-	 */
-	if (ath_rc_priv->per[tx_rate] >= 55 && tx_rate > 0 &&
-	    rate_table->info[tx_rate].ratekbps <=
-	    rate_table->info[ath_rc_priv->rate_max_phy].ratekbps) {
-		ath_rc_get_lower_rix(rate_table, ath_rc_priv,
-				     (u8)tx_rate, &ath_rc_priv->rate_max_phy);
-
-		/* Don't probe for a little while. */
-		ath_rc_priv->probe_time = now_msec;
-	}
-
-	/* Make sure the rates below this have lower PER */
-	/* Monotonicity is kept only for rates below the current rate. */
-	if (ath_rc_priv->per[tx_rate] < last_per) {
-		for (rate = tx_rate - 1; rate >= 0; rate--) {
-
-			if (ath_rc_priv->per[rate] >
-			    ath_rc_priv->per[rate+1]) {
-				ath_rc_priv->per[rate] =
-					ath_rc_priv->per[rate+1];
-			}
-		}
-	}
-
-	/* Maintain monotonicity for rates above the current rate */
-	for (rate = tx_rate; rate < size - 1; rate++) {
-		if (ath_rc_priv->per[rate+1] <
-		    ath_rc_priv->per[rate])
-			ath_rc_priv->per[rate+1] =
-				ath_rc_priv->per[rate];
-	}
-
-	/* Every so often, we reduce the thresholds
-	 * and PER (different for CCK and OFDM). */
-	if (now_msec - ath_rc_priv->per_down_time >=
-	    rate_table->probe_interval) {
-		for (rate = 0; rate < size; rate++) {
-			ath_rc_priv->per[rate] =
-				7 * ath_rc_priv->per[rate] / 8;
-		}
+	struct ieee80211_tx_rate *rates = tx_info->status.rates;
+	struct ath_rateset *rateset;
+	struct rc_tx_rates tx_rate;
+	u8 pdr[5], n_bad_frames, max_idx;
+	u16 rc_counter;
+	int i = 0, tp[5];
 
-		ath_rc_priv->per_down_time = now_msec;
+	if (tx_info->status.ack_signal > 0){
+		ath_rc_priv->current_rssi = tx_info->status.ack_signal;
+		if (tx_info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			ath_rc_priv->current_rssi += 3;
 	}
 
-	ath_debug_stat_retries(ath_rc_priv, tx_rate, xretries, retries,
-			       ath_rc_priv->per[tx_rate]);
-
-}
-
-
-static void ath_rc_tx_status(struct ath_softc *sc,
-			     struct ath_rate_priv *ath_rc_priv,
-			     struct ieee80211_tx_info *tx_info,
-			     int final_ts_idx, int xretries, int long_retry)
-{
-	const struct ath_rate_table *rate_table;
-	struct ieee80211_tx_rate *rates = tx_info->status.rates;
-	u8 flags;
-	u32 i = 0, rix;
-
-	rate_table = ath_rc_priv->rate_table;
+	rateset = &ath_rc_priv->rssi_rates[tx_info->status.rateset_index];
+	n_bad_frames = tx_info->status.ampdu_len - tx_info->status.ampdu_ack_len;
+	rateset->rs_rates[tx_info->status.rate_index].nframe_bad[tx_info->status.nframes - 1] += n_bad_frames;
+	rateset->rs_rates[tx_info->status.rate_index].nframe_ok[tx_info->status.nframes - 1] += tx_info->status.ampdu_ack_len;
 
-	/*
-	 * If the first rate is not the final index, there
-	 * are intermediate rate failures to be processed.
-	 */
-	if (final_ts_idx != 0) {
-		/* Process intermediate rates that failed.*/
-		for (i = 0; i < final_ts_idx ; i++) {
-			if (rates[i].count != 0 && (rates[i].idx >= 0)) {
-				flags = rates[i].flags;
-
-				/* If HT40 and we have switched mode from
-				 * 40 to 20 => don't update */
-
-				if ((flags & IEEE80211_TX_RC_40_MHZ_WIDTH) &&
-				    !(ath_rc_priv->ht_cap & WLAN_RC_40_FLAG))
-					return;
-
-				rix = ath_rc_get_rateindex(rate_table, &rates[i]);
-				ath_rc_update_ht(sc, ath_rc_priv, tx_info,
-						rix, xretries ? 1 : 2,
-						rates[i].count);
+#define TX_OK_N(i) tx_rate.nframe_ok[tx_rate.current_nf + i - 1]
+#define TX_BAD_N(i) tx_rate.nframe_bad[tx_rate.current_nf + i - 1]
+/* TX_CAL_TP(i) calculate throughput for current rate(4), higher rate(0), lower rate(1), bigger fa(2), smaller fa(3) */
+#define TX_CAL_TP(i) do {											\
+		if (rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)			\
+			tp[i] = pdr[i] * rate_table->info[tx_rate.idx + 8 + 16].ratekbps;	\
+		else													\
+			tp[i] = pdr[i] * rate_table->info[tx_rate.idx + 8].ratekbps;	\
+	} while (0)
+
+	rateset->rc_count += tx_info->status.ampdu_len;
+	rc_counter = rateset->rc_count >> 11;
+	if (rc_counter > 0){
+		/* probe is over */
+		for (i = 0 ; i < 5 ; i++){
+			pdr[i] = 0;
+			tp[i] = 0;
+		}
+		tx_rate = rateset->rs_rates[rateset->current_rate];
+		pdr[4] = TX_OK_N(0) * 100 / (TX_OK_N(0) + TX_BAD_N(0));
+		TX_CAL_TP(4);
+		TX_OK_N(0) = TX_BAD_N(0) = 0;
+		if (rateset->current_rate > 0 && TX_OK_N(0) > 0){
+			tx_rate = rateset->rs_rates[rateset->current_rate - 1];
+			if (!tx_rate.disable){
+				pdr[0] = TX_OK_N(0) * 100 / (TX_OK_N(0) + TX_BAD_N(0));
+				TX_CAL_TP(0);
+				TX_OK_N(0) = TX_BAD_N(0) = 0;
 			}
 		}
-	} else {
-		/*
-		 * Handle the special case of MIMO PS burst, where the second
-		 * aggregate is sent out with only one rate and one try.
-		 * Treating it as an excessive retry penalizes the rate
-		 * inordinately.
-		 */
-		if (rates[0].count == 1 && xretries == 1)
-			xretries = 2;
-	}
-
-	flags = rates[i].flags;
+		if (rateset->current_rate < rateset->rs_nrates - 1 && TX_OK_N(0) > 0){
+			tx_rate = rateset->rs_rates[rateset->current_rate + 1];
+			pdr[1] = TX_OK_N(0) * 100 / (TX_OK_N(0) + TX_BAD_N(0));
+			TX_CAL_TP(1);
+			TX_OK_N(0) = TX_BAD_N(0) = 0;
+		}
+		if (rateset->rs_rates[rateset->current_rate].current_nf > 1 && TX_OK_N(-1) > 0){
+			tx_rate = rateset->rs_rates[rateset->current_rate];
+			pdr[2] = TX_OK_N(-1) * 100 / (TX_OK_N(-1) + TX_BAD_N(-1));
+			TX_CAL_TP(2);
+			TX_OK_N(-1) = TX_BAD_N(-1) = 0;
+		}
+		if (rateset->rs_rates[rateset->current_rate].current_nf < 32 && TX_OK_N(1) > 0){
+			tx_rate = rateset->rs_rates[rateset->current_rate];
+			pdr[3] = TX_OK_N(1) * 100 / (TX_OK_N(1) + TX_BAD_N(1));
+			TX_CAL_TP(3);
+			TX_OK_N(1) = TX_BAD_N(1) = 0;
+		}
+		max_idx = 4;
+		for (i = 3 ; i >= 0 ; i--)
+			if (tp[i] > tp[max_idx])
+				max_idx = i;
+
+		rateset->rs_rates[rateset->current_rate].need_probe = true;
+
+		if (pdr[4] < 30 && rateset->current_rate < rateset->rs_nrates - 1){
+			rateset->rs_rates[rateset->current_rate].disable = true;
+			rateset->rs_rates[rateset->current_rate].disabletime = jiffies;
+		}
+		if (max_idx == 0 && pdr[0] > 30){
+			rateset->current_rate--;
+		} else if (pdr[0] < 30 && rateset->current_rate > 0) {
+			rateset->rs_rates[rateset->current_rate - 1].disable = true;
+			rateset->rs_rates[rateset->current_rate - 1].disabletime = jiffies;
+		}
+		if (max_idx == 1){
+			rateset->current_rate++;
+		}
+		if (max_idx == 2){
+			rateset->rs_rates[rateset->current_rate].current_nf--;
+		}
+		if (max_idx == 3){
+			rateset->rs_rates[rateset->current_rate].current_nf++;
+		}
+		if (pdr[max_idx] < 50 && max_idx != 1 && rateset->current_rate < rateset->rs_nrates - 1)
+			rateset->current_rate++;
+
+		if (pdr[max_idx] > 95)
+			rateset->rs_rates[rateset->current_rate].need_probe = false;
+
+		rateset->rc_count = 0;
+	}
+#undef TX_CAL_TP
+#undef TX_OK_N
+#undef TX_BAD_N
 
-	/* If HT40 and we have switched mode from 40 to 20 => don't update */
-	if ((flags & IEEE80211_TX_RC_40_MHZ_WIDTH) &&
-	    !(ath_rc_priv->ht_cap & WLAN_RC_40_FLAG))
-		return;
-
-	rix = ath_rc_get_rateindex(rate_table, &rates[i]);
-	ath_rc_update_ht(sc, ath_rc_priv, tx_info, rix, xretries, long_retry);
+	if (rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+		ath_debug_stat(ath_rc_priv, rates[0].idx + 16, tx_info->status.ampdu_len - 1, tx_info->status.ampdu_ack_len, n_bad_frames);
+	else
+		ath_debug_stat(ath_rc_priv, rates[0].idx, tx_info->status.ampdu_len - 1, tx_info->status.ampdu_ack_len, n_bad_frames);
 }
 
 static const
@@ -1187,98 +540,25 @@
 					     enum ieee80211_band band,
 					     bool is_ht)
 {
-	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	/**
+	 * here is very strange, our driver supports HT so the parameter
+	 * should have been true, but in fact it is false.
+	 * if (WARN_ON(!is_ht))
+	 * 		return NULL;
+	 * */
 
 	switch(band) {
 	case IEEE80211_BAND_2GHZ:
-		if (is_ht)
-			return &ar5416_11ng_ratetable;
-		return &ar5416_11g_ratetable;
+		WARN_ON(1);
+		printk("[WARN]The algorithm doesn't consider about 2.4GHz!\n");
+		return &ar5416_11ng_ratetable;
 	case IEEE80211_BAND_5GHZ:
-		if (is_ht)
-			return &ar5416_11na_ratetable;
-		return &ar5416_11a_ratetable;
+		return &ar5416_11na_ratetable;
 	default:
-		ath_dbg(common, ATH_DBG_CONFIG, "Invalid band\n");
 		return NULL;
 	}
 }
 
-static void ath_rc_init(struct ath_softc *sc,
-			struct ath_rate_priv *ath_rc_priv,
-			struct ieee80211_supported_band *sband,
-			struct ieee80211_sta *sta,
-			const struct ath_rate_table *rate_table)
-{
-	struct ath_rateset *rateset = &ath_rc_priv->neg_rates;
-	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-	u8 *ht_mcs = (u8 *)&ath_rc_priv->neg_ht_rates;
-	u8 i, j, k, hi = 0, hthi = 0;
-
-	/* Initial rate table size. Will change depending
-	 * on the working rate set */
-	ath_rc_priv->rate_table_size = RATE_TABLE_SIZE;
-
-	/* Initialize thresholds according to the global rate table */
-	for (i = 0 ; i < ath_rc_priv->rate_table_size; i++) {
-		ath_rc_priv->per[i] = 0;
-	}
-
-	/* Determine the valid rates */
-	ath_rc_init_valid_rate_idx(ath_rc_priv);
-
-	for (i = 0; i < WLAN_RC_PHY_MAX; i++) {
-		for (j = 0; j < MAX_TX_RATE_PHY; j++)
-			ath_rc_priv->valid_phy_rateidx[i][j] = 0;
-		ath_rc_priv->valid_phy_ratecnt[i] = 0;
-	}
-
-	if (!rateset->rs_nrates) {
-		/* No working rate, just initialize valid rates */
-		hi = ath_rc_init_validrates(ath_rc_priv, rate_table,
-					    ath_rc_priv->ht_cap);
-	} else {
-		/* Use intersection of working rates and valid rates */
-		hi = ath_rc_setvalid_rates(ath_rc_priv, rate_table,
-					   rateset, ath_rc_priv->ht_cap);
-		if (ath_rc_priv->ht_cap & WLAN_RC_HT_FLAG) {
-			hthi = ath_rc_setvalid_htrates(ath_rc_priv,
-						       rate_table,
-						       ht_mcs,
-						       ath_rc_priv->ht_cap);
-		}
-		hi = max(hi, hthi);
-	}
-
-	ath_rc_priv->rate_table_size = hi + 1;
-	ath_rc_priv->rate_max_phy = 0;
-	BUG_ON(ath_rc_priv->rate_table_size > RATE_TABLE_SIZE);
-
-	for (i = 0, k = 0; i < WLAN_RC_PHY_MAX; i++) {
-		for (j = 0; j < ath_rc_priv->valid_phy_ratecnt[i]; j++) {
-			ath_rc_priv->valid_rate_index[k++] =
-				ath_rc_priv->valid_phy_rateidx[i][j];
-		}
-
-		if (!ath_rc_valid_phyrate(i, rate_table->initial_ratemax, 1)
-		    || !ath_rc_priv->valid_phy_ratecnt[i])
-			continue;
-
-		ath_rc_priv->rate_max_phy = ath_rc_priv->valid_phy_rateidx[i][j-1];
-	}
-	BUG_ON(ath_rc_priv->rate_table_size > RATE_TABLE_SIZE);
-	BUG_ON(k > RATE_TABLE_SIZE);
-
-	ath_rc_priv->max_valid_rate = k;
-	ath_rc_sort_validrates(rate_table, ath_rc_priv);
-	ath_rc_priv->rate_max_phy = ath_rc_priv->valid_rate_index[k-4];
-	ath_rc_priv->rate_table = rate_table;
-
-	ath_dbg(common, ATH_DBG_CONFIG,
-		"RC Initialized with capabilities: 0x%x\n",
-		ath_rc_priv->ht_cap);
-}
-
 static u8 ath_rc_build_ht_caps(struct ath_softc *sc, struct ieee80211_sta *sta,
 			       bool is_cw40, bool is_sgi)
 {
@@ -1319,15 +599,6 @@
 /* mac80211 Rate Control callbacks */
 /***********************************/
 
-static void ath_debug_stat_rc(struct ath_rate_priv *rc, int final_rate)
-{
-	struct ath_rc_stats *stats;
-
-	stats = &rc->rcstats[final_rate];
-	stats->success++;
-}
-
-
 static void ath_tx_status(void *priv, struct ieee80211_supported_band *sband,
 			  struct ieee80211_sta *sta, void *priv_sta,
 			  struct sk_buff *skb)
@@ -1336,21 +607,11 @@
 	struct ath_rate_priv *ath_rc_priv = priv_sta;
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr;
-	int final_ts_idx = 0, tx_status = 0;
-	int long_retry = 0;
+	int tx_status = 1;
 	__le16 fc;
-	int i;
 
 	hdr = (struct ieee80211_hdr *)skb->data;
 	fc = hdr->frame_control;
-	for (i = 0; i < sc->hw->max_rates; i++) {
-		struct ieee80211_tx_rate *rate = &tx_info->status.rates[i];
-		if (!rate->count)
-			break;
-
-		final_ts_idx = i;
-		long_retry = rate->count - 1;
-	}
 
 	if (!priv_sta || !ieee80211_is_data(fc))
 		return;
@@ -1364,10 +625,9 @@
 		return;
 
 	if (!(tx_info->flags & IEEE80211_TX_STAT_ACK))
-		tx_status = 1;
+		tx_status = 0;
 
-	ath_rc_tx_status(sc, ath_rc_priv, tx_info, final_ts_idx, tx_status,
-			 long_retry);
+	ath_rc_tx_status(sc, ath_rc_priv, tx_info, tx_status);
 
 	/* Check if aggregation has to be enabled for this tid */
 	if (conf_is_ht(&sc->hw->conf) &&
@@ -1385,10 +645,128 @@
 				ieee80211_start_tx_ba_session(sta, tid, 0);
 		}
 	}
+}
+
+static void init_rate_set(struct ath_rateset *rssi_rates, int size, u8 mcs[]) {
+	int i, j;
+	for (i = 0 ; i < size ; i++){
+		if (mcs[i] < 16){
+			rssi_rates->rs_rates[i].idx = mcs[i];
+			rssi_rates->rs_rates[i].flags = IEEE80211_TX_RC_MCS;
+		} else {
+			rssi_rates->rs_rates[i].idx = mcs[i] - 16;
+			rssi_rates->rs_rates[i].flags = IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_40_MHZ_WIDTH | IEEE80211_TX_RC_SHORT_GI;
+		}
+		for (j = 0 ; j < NFRAME_MAX ; j++){
+			rssi_rates->rs_rates[i].nframe_ok[j] = 0;
+			rssi_rates->rs_rates[i].nframe_bad[j] = 0;
+		}
+		rssi_rates->rs_rates[i].current_nf = 32;
+		rssi_rates->rs_rates[i].disable = false;
+		rssi_rates->rs_rates[i].need_probe = true;
+	}
+	rssi_rates->rs_nrates += size;
+}
+
+static void init_ratesets(struct ath_rate_priv *ath_rc_priv, bool is_cw40){
+	int i, j;
+	u8 mcs[NRATE_IN_LEVEL];
+
+	if (is_cw40){
+		for (i = 0 ; i < 11 ; i++){
+			ath_rc_priv->rssi_rates[i].rs_nrates = 0;
+			ath_rc_priv->rssi_rates[i].rc_count = 0;
+		}
+
+		mcs[0] = 1, mcs[1] = 0;
+		init_rate_set(&ath_rc_priv->rssi_rates[0], 2, mcs);
+
+		mcs[0] = 2, mcs[1] = 8, mcs[2] = 1, mcs[3] = 0;
+		init_rate_set(&ath_rc_priv->rssi_rates[1], 4, mcs);
+
+		mcs[0] = 8 + 16, mcs[1] = 9;
+		init_rate_set(&ath_rc_priv->rssi_rates[2], 2, mcs);
+
+		mcs[0] = 2 + 16, mcs[1] = 1 + 16, mcs[3] = 0 + 16;
+		mcs[2] = 2,
+		init_rate_set(&ath_rc_priv->rssi_rates[3], 4, mcs);
+
+		mcs[0] = 9 + 16;
+		mcs[1] = 10, mcs[2] = 3;
+		init_rate_set(&ath_rc_priv->rssi_rates[4], 3, mcs);
+
+		mcs[0] = 9 + 16;
+		mcs[1] = 11, mcs[2] = 4;
+		init_rate_set(&ath_rc_priv->rssi_rates[5], 3, mcs);
+
+		mcs[0] = 10 + 16, mcs[1] = 3 + 16;
+		mcs[2] = 11, mcs[3] = 4;
+		init_rate_set(&ath_rc_priv->rssi_rates[6], 4, mcs);
+
+		mcs[0] = 11 + 16, mcs[1] = 4 + 16;
+		mcs[2] = 11, mcs[3] = 4;
+		init_rate_set(&ath_rc_priv->rssi_rates[7], 4, mcs);
+
+		mcs[0] = 11 + 16, mcs[1] = 4 + 16;
+		mcs[2] = 12, mcs[3] = 5;
+		init_rate_set(&ath_rc_priv->rssi_rates[8], 4, mcs);
+
+		mcs[0] = 12 + 16, mcs[1] = 5 + 16;
+		mcs[2] = 13, mcs[3] = 7, mcs[4] = 6;
+		init_rate_set(&ath_rc_priv->rssi_rates[9], 5, mcs);
+
+		mcs[0] = 15 + 16, mcs[1] = 14 + 16, mcs[2] = 13 + 16, mcs[3] = 7 + 16, mcs[5] = 6 + 16;
+		mcs[4] = 15, mcs[6] = 14, mcs[7] = 13, mcs[8] = 7;
+		init_rate_set(&ath_rc_priv->rssi_rates[10], 9, mcs);
+
+		ath_rc_priv->real_nlevel = 11;
+
+		for (i = 0 ; i < 11 ; i++){
+			ath_rc_priv->rssi_rates[i].current_rate = 0/*ath_rc_priv->rssi_rates[i].rs_nrates / 2*/;
+		}
+	} else {
+		for (i = 0 ; i < 8 ; i++){
+			ath_rc_priv->rssi_rates[i].rs_nrates = 0;
+			ath_rc_priv->rssi_rates[i].rc_count = 0;
+		}
+
+		mcs[0] = 8, mcs[1] = 0;
+		init_rate_set(&ath_rc_priv->rssi_rates[0], 2, mcs);
+
+		mcs[0] = 9, mcs[1] = 8, mcs[2] = 1, mcs[3] = 0;
+		init_rate_set(&ath_rc_priv->rssi_rates[1], 4, mcs);
+
+		mcs[0] = 2;
+		init_rate_set(&ath_rc_priv->rssi_rates[2], 1, mcs);
+
+		mcs[0] = 10, mcs[1] = 3;
+		init_rate_set(&ath_rc_priv->rssi_rates[3], 2, mcs);
+
+		mcs[0] = 11, mcs[1] = 4;
+		init_rate_set(&ath_rc_priv->rssi_rates[4], 2, mcs);
+
+		mcs[0] = 12, mcs[1] = 5;
+		init_rate_set(&ath_rc_priv->rssi_rates[5], 2, mcs);
+
+		mcs[0] = 13, mcs[1] = 7, mcs[2] = 6;
+		init_rate_set(&ath_rc_priv->rssi_rates[6], 3, mcs);
+
+		mcs[0] = 15, mcs[1] = 14, mcs[2] = 13, mcs[3] = 7;
+		init_rate_set(&ath_rc_priv->rssi_rates[7], 5, mcs);
+
+		ath_rc_priv->real_nlevel = 8;
+
+		for (i = 0 ; i < 11 ; i++){
+			ath_rc_priv->rssi_rates[i].current_rate = ath_rc_priv->rssi_rates[i].rs_nrates / 2;
+		}
+	}
+	ath_rc_priv->current_rssi = 11;
 
-	ath_debug_stat_rc(ath_rc_priv,
-		ath_rc_get_rateindex(ath_rc_priv->rate_table,
-			&tx_info->status.rates[final_ts_idx]));
+	for (i = 0 ; i < 32 ; i++)
+		for (j = 0 ; j < 32 ; j++){
+			ath_rc_priv->rcstats[i][j].success = 0;
+			ath_rc_priv->rcstats[i][j].fail = 0;
+		}
 }
 
 static void ath_rate_init(void *priv, struct ieee80211_supported_band *sband,
@@ -1398,26 +776,6 @@
 	struct ath_rate_priv *ath_rc_priv = priv_sta;
 	const struct ath_rate_table *rate_table;
 	bool is_cw40, is_sgi = false;
-	int i, j = 0;
-
-	for (i = 0; i < sband->n_bitrates; i++) {
-		if (sta->supp_rates[sband->band] & BIT(i)) {
-			ath_rc_priv->neg_rates.rs_rates[j]
-				= (sband->bitrates[i].bitrate * 2) / 10;
-			j++;
-		}
-	}
-	ath_rc_priv->neg_rates.rs_nrates = j;
-
-	if (sta->ht_cap.ht_supported) {
-		for (i = 0, j = 0; i < 77; i++) {
-			if (sta->ht_cap.mcs.rx_mask[i/8] & (1<<(i%8)))
-				ath_rc_priv->neg_ht_rates.rs_rates[j++] = i;
-			if (j == ATH_RATE_MAX)
-				break;
-		}
-		ath_rc_priv->neg_ht_rates.rs_nrates = j;
-	}
 
 	is_cw40 = !!(sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40);
 
@@ -1430,9 +788,10 @@
 
 	rate_table = ath_choose_rate_table(sc, sband->band,
 	                      sta->ht_cap.ht_supported);
+	ath_rc_priv->rate_table = rate_table;
 
+	init_ratesets(ath_rc_priv, is_cw40);
 	ath_rc_priv->ht_cap = ath_rc_build_ht_caps(sc, sta, is_cw40, is_sgi);
-	ath_rc_init(sc, priv_sta, sband, sta, rate_table);
 }
 
 static void ath_rate_update(void *priv, struct ieee80211_supported_band *sband,
@@ -1470,7 +829,7 @@
 						   sta->ht_cap.ht_supported);
 			ath_rc_priv->ht_cap = ath_rc_build_ht_caps(sc, sta,
 						   oper_cw40, oper_sgi);
-			ath_rc_init(sc, priv_sta, sband, sta, rate_table);
+			ath_rc_priv->rate_table = rate_table;
 
 			ath_dbg(ath9k_hw_common(sc->sc_ah), ATH_DBG_CONFIG,
 				"Operating HT Bandwidth changed to: %d\n",
@@ -1492,60 +851,36 @@
 {
 	struct ath_rate_priv *rc = file->private_data;
 	char *buf;
-	unsigned int len = 0, max;
-	int i = 0;
+	unsigned int len = 0, size = 33 * 33 * 18, i, j;
 	ssize_t retval;
 
-	if (rc->rate_table == NULL)
-		return 0;
-
-	max = 80 + rc->rate_table_size * 1024 + 1;
-	buf = kmalloc(max, GFP_KERNEL);
+	buf = kmalloc(size, GFP_KERNEL);
 	if (buf == NULL)
 		return -ENOMEM;
 
-	len += sprintf(buf, "%6s %6s %6s "
-		       "%10s %10s %10s %10s\n",
-		       "HT", "MCS", "Rate",
-		       "Success", "Retries", "XRetries", "PER");
-
-	for (i = 0; i < rc->rate_table_size; i++) {
-		u32 ratekbps = rc->rate_table->info[i].ratekbps;
-		struct ath_rc_stats *stats = &rc->rcstats[i];
-		char mcs[5];
-		char htmode[5];
-		int used_mcs = 0, used_htmode = 0;
-
-		if (WLAN_RC_PHY_HT(rc->rate_table->info[i].phy)) {
-			used_mcs = snprintf(mcs, 5, "%d",
-				rc->rate_table->info[i].ratecode);
-
-			if (WLAN_RC_PHY_40(rc->rate_table->info[i].phy))
-				used_htmode = snprintf(htmode, 5, "HT40");
-			else if (WLAN_RC_PHY_20(rc->rate_table->info[i].phy))
-				used_htmode = snprintf(htmode, 5, "HT20");
-			else
-				used_htmode = snprintf(htmode, 5, "????");
-		}
-
-		mcs[used_mcs] = '\0';
-		htmode[used_htmode] = '\0';
-
-		len += snprintf(buf + len, max - len,
-			"%6s %6s %3u.%d: "
-			"%10u %10u %10u %10u\n",
-			htmode,
-			mcs,
-			ratekbps / 1000,
-			(ratekbps % 1000) / 100,
-			stats->success,
-			stats->retries,
-			stats->xretries,
-			stats->per);
+	len += snprintf(buf, size, "%13s", "success/fail");
+	for (i = 0 ; i < 32 ; i++)
+		len += snprintf(buf + len, size - len, "%6d%-11s", i+1, "-frame");
+	len += snprintf(buf + len, size - len, "\n");
+
+	for (i = 0; i < 32; i++) {
+		struct ath_rc_stats *stats;
+
+		if (i < 16){
+			len += snprintf(buf + len, size - len, "HT20 MCS-%-3d:", i);
+		} else {
+			len += snprintf(buf + len, size - len, "HT40 MCS-%-3d:", i - 16);
+		}
+
+		for (j = 0 ; j < 32 ; j++){
+			stats = &rc->rcstats[i][j];
+			len += snprintf(buf + len, size - len, "%8d/%-7d|", stats->success, stats->fail);
+		}
+		len += snprintf(buf + len, size - len, "\n");
 	}
 
-	if (len > max)
-		len = max;
+	if (len > size)
+		len = size;
 
 	retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
 	kfree(buf);
--- a/drivers/net/wireless/ath/ath9k/rc.h	2013-03-07 21:37:03.000000000 +0800
+++ b/drivers/net/wireless/ath/ath9k/rc.h	2013-03-05 13:01:51.000000000 +0800
@@ -1,3 +1,4 @@
+/* !!!file to change!!! */
 /*
  * Copyright (c) 2004 Sam Leffler, Errno Consulting
  * Copyright (c) 2004 Video54 Technologies, Inc.
@@ -23,10 +24,10 @@
 
 struct ath_softc;
 
-#define ATH_RATE_MAX     30
-#define RATE_TABLE_SIZE  72
-#define MAX_TX_RATE_PHY  48
-
+#define NFRAME_MAX	     32
+#define RATE_LEVEL_MAX	 11
+#define NRATE_IN_LEVEL	 10
+#define RATE_TABLE_SIZE  44
 
 #define RC_INVALID	0x0000
 #define RC_LEGACY	0x0001
@@ -140,17 +141,12 @@
  * @rate_flags: Rate Control flags
  * @phy: CCK/OFDM/HT20/HT40
  * @ratekbps: rate in Kbits per second
- * @user_ratekbps: user rate in Kbits per second
  * @ratecode: rate that goes into HW descriptors
  * @dot11rate: value that goes into supported
  * 	rates info element of MLME
  * @ctrl_rate: Index of next lower basic rate, used for duration computation
- * @cw40index: Index of rates having 40MHz channel width
- * @sgi_index: Index of rates having Short Guard Interval
  * @ht_index: high throughput rates having 40MHz channel width and
  * 	Short Guard Interval
- * @probe_interval: interval for rate control to probe for other rates
- * @initial_ratemax: initial ratemax value
  */
 struct ath_rate_table {
 	int rate_cnt;
@@ -159,66 +155,54 @@
 		u16 rate_flags;
 		u8 phy;
 		u32 ratekbps;
-		u32 user_ratekbps;
 		u8 ratecode;
 		u8 dot11rate;
 		u8 ctrl_rate;
-		u8 cw40index;
-		u8 sgi_index;
 		u8 ht_index;
 	} info[RATE_TABLE_SIZE];
-	u32 probe_interval;
-	u8 initial_ratemax;
+};
+
+/**
+ * struct rc_tx_rates - Rate info
+ * @need_probe: Need to probe to lower rate or fa
+ */
+struct rc_tx_rates {
+	s8 idx;
+	u8 flags;
+	u8 current_nf;
+	bool disable;
+	unsigned long disabletime;
+	bool need_probe;
+	u16 nframe_ok[NFRAME_MAX];
+	u16 nframe_bad[NFRAME_MAX];
 };
 
 struct ath_rateset {
+	u16 rc_count;
 	u8 rs_nrates;
-	u8 rs_rates[ATH_RATE_MAX];
+	u8 current_rate;
+	struct rc_tx_rates rs_rates[NRATE_IN_LEVEL];
 };
 
 struct ath_rc_stats {
 	u32 success;
-	u32 retries;
-	u32 xretries;
-	u8 per;
+	u32 fail;
 };
 
 /**
  * struct ath_rate_priv - Rate Control priv data
- * @state: RC state
- * @probe_rate: rate we are probing at
- * @probe_time: msec timestamp for last probe
- * @hw_maxretry_pktcnt: num of packets since we got HW max retry error
- * @max_valid_rate: maximum number of valid rate
- * @per_down_time: msec timestamp for last PER down step
- * @valid_phy_ratecnt: valid rate count
- * @rate_max_phy: phy index for the max rate
- * @per: PER for every valid rate in %
- * @probe_interval: interval for ratectrl to probe for other rates
  * @ht_cap: HT capabilities
- * @neg_rates: Negotatied rates
- * @neg_ht_rates: Negotiated HT rates
  */
 struct ath_rate_priv {
-	u8 rate_table_size;
-	u8 probe_rate;
-	u8 hw_maxretry_pktcnt;
-	u8 max_valid_rate;
-	u8 valid_rate_index[RATE_TABLE_SIZE];
 	u8 ht_cap;
-	u8 valid_phy_ratecnt[WLAN_RC_PHY_MAX];
-	u8 valid_phy_rateidx[WLAN_RC_PHY_MAX][RATE_TABLE_SIZE];
-	u8 rate_max_phy;
-	u8 per[RATE_TABLE_SIZE];
-	u32 probe_time;
-	u32 per_down_time;
-	u32 probe_interval;
-	struct ath_rateset neg_rates;
-	struct ath_rateset neg_ht_rates;
 	const struct ath_rate_table *rate_table;
 
+	struct ath_rateset rssi_rates[RATE_LEVEL_MAX];
+	int real_nlevel;
+	int current_rssi;
+
 	struct dentry *debugfs_rcstats;
-	struct ath_rc_stats rcstats[RATE_TABLE_SIZE];
+	struct ath_rc_stats rcstats[32][32];
 };
 
 #ifdef CONFIG_ATH9K_RATE_CONTROL
--- a/drivers/net/wireless/ath/ath9k/xmit.c	2013-03-07 21:37:03.000000000 +0800
+++ b/drivers/net/wireless/ath/ath9k/xmit.c	2013-03-07 15:26:43.000000000 +0800
@@ -813,7 +813,7 @@
 {
 #define PADBYTES(_len) ((4 - ((_len) % 4)) % 4)
 	struct ath_buf *bf, *bf_first = NULL, *bf_prev = NULL;
-	int rl = 0, nframes = 0, ndelim, prev_al = 0;
+	int rl = 0, nframes = 0, ndelim, prev_al = 0, max_frame = -1;
 	u16 aggr_limit = 0, al = 0, bpad = 0,
 		al_delta, h_baw = tid->baw_size / 2;
 	enum ATH_AGGR_STATUS status = ATH_AGGR_DONE;
@@ -875,8 +875,11 @@
 		if (nframes && (tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE))
 			break;
 
+		if (max_frame < 0){
+			max_frame = tx_info->control.nframes;
+		}
 		/* do not exceed subframe limit */
-		if (nframes >= min((int)h_baw, ATH_AMPDU_SUBFRAME_DEFAULT)) {
+		if (nframes >= min((int)h_baw, max_frame)) {
 			status = ATH_AGGR_LIMITED;
 			break;
 		}
